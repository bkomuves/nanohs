
main = runIO action2

action1 = ioseq (putChar '1') (putChar '2')

action2 = iosequence_
  [ putStrLn "1 hello IO world !!!"
  , putStrLn "2 alma"
  , putStrLn "3 korte"
  ]

----------------------------------

type IO a = Unit -> a

runIO :: IO a -> a
runIO action = action Unit

ioreturn :: a -> IO a
ioreturn x = \_ -> x

ioret_ :: IO Unit
ioret_ = \_ -> Unit

-- | Note: we have to be very careful about how to implement bind!
-- (because we are cheating with ML-style IO)
iobind :: IO a -> (a -> IO b) -> IO b
iobind action u _ = u (action Unit) Unit

ioseq :: IO a -> IO b -> IO b
ioseq f g = iobind f (\_ -> g)

iosequence_ :: List (IO a) -> IO Unit
iosequence_ list = case list of { Nil -> ioret_ ; Cons a as -> ioseq a (iosequence_ as) }

getChar :: IO (Maybe Char)
getChar = getChar#

putChar :: Char -> IO Unit
putChar c = \_ -> putChar# c

exit :: Int -> IO Unit
exit k = \_ -> exit# k

-- getArg :: Int -> IO String
-- getArg i = \_ -> getArg# i 

putStr :: String -> IO Unit
putStr xs = case xs of  { Nil -> ioret_ ; Cons y ys -> ioseq (putChar y) (putStr ys) }

putStrLn :: String -> IO Unit
putStrLn str = ioseq (putStr str) (putChar (chr 10)) 

----------------------------------

compose :: (b -> c) -> (a -> b) -> (a -> c)
compose f g = \x -> f (g x)

listAnd xs = case xs of { Nil -> True ; Cons b bs -> and b (listAnd bs) }

listOr  = go where { go xs = case xs of { Nil -> False ; Cons b bs -> or b (go bs) } }

map :: (a -> b) -> List a -> List b
map f = go where { go xs = case xs of { Nil -> Nil ; Cons x xs -> Cons (f x) (map f xs) } }

for :: List a -> (a -> b) -> List b
for xs f = map f xs

filter :: (a -> Bool) -> List a -> List a
filter f = go where
  { go list = case list of
     { Nil -> Nil ; Cons x xs -> case f x of
       { False -> go xs ; True -> Cons x (go xs) } } }

inc :: Int -> Int
inc n = plus n 1

dec :: Int -> Int
dec n = minus n 1

gt :: Int -> Int -> Bool
gt x y = lt y x

ge :: Int -> Int -> Bool
ge x y = le y x

-- | the list [0,1,...n-1]
range :: Int -> List Int
range = rangeFrom 0

-- | the list [k,k+1,...k+n-1]
rangeFrom :: Int -> Int -> List Int
rangeFrom k n = ifte (gt n 0) (Cons k (rangeFrom (inc k) (dec n))) Nil

foldl :: (a -> b -> a) -> (a -> List b -> a)
foldl f x0 list = go x0 list where
  { go x ls = case ls of { Nil -> x ; Cons y ys -> go (f x y) ys }
  }

flipFoldr :: (b -> a -> a) -> (List b -> a -> a)
flipFoldr f list y0 = go list y0 where
  { go ls y = case ls of { Nil -> y ; Cons x xs -> f x (go xs y) }
  }

foldr :: (b -> a -> a) -> (a -> List b -> a)
foldr f x list = flipFoldr f list x

sum :: List Int -> Int
sum = foldl plus 0 

reverse :: List a -> List a
reverse = foldl (\xs x -> Cons x xs) Nil 


