

nanoMain = runIO (putStrLn text2)

-- action7 = iobind (readFile "a.txt" ReadMode) (\text -> putStrLn text)
-- action7 = iobind (withFile "a.txt" ReadMode hGetContents) (\text -> putStrLn (unlines (map ff (lines text))))

text  = unlines [ "alma" , "korte" , "szilva" ]
text2 = unlines (map ff (lines text))
ff x  = append ">>> " x

action6 = iobind getArgs (\list -> iosequence_
  [ putStrLn (append "argc = " (showInt (length list)))
  , iomapM_ putStrLn list
  ])

action5 =  (
  iobind (openFile "a.txt" ReadMode) (\h -> 
  iobind (hGetContents h) (\text ->
  iobind (hClose h)       (\_ -> 
  putStrLn text  ))))

-- main = runIO (
--   iobind (openFile "a.txt" ReadMode) (\h -> 
--   iobind (hGetChar h)                (\mbc ->  
--   iobind (case mbc of { Just c -> putChar c ; Nothing -> putStr "EOF" })  (\_ ->
--          (ioreturn mbc)
--   ))))

-- action3 = iobind (readFile "a.txt" ReadMode) putStrLn

-- main = runIO (iobind (readFile "a.txt" ReadMode) (\text -> putStrLn text))
-- main = runIO (iobind (readFile "a.txt" ReadMode)

action1 = ioseq (putChar '1') (putChar '2')

action2 = iosequence_
  [ putStrLn "1 hello IO world !!!"
  , putStrLn "2 alma"
  , putStrLn "3 korte"
  ]

--------------------------------------------------------------------------------
-- ** IO Monad

type IO a = Unit -> a

runIO :: IO a -> a
runIO action = action Unit

ioreturn :: a -> IO a
ioreturn x = \_ -> x

ioret_ :: IO Unit
ioret_ = \_ -> Unit

-- | Note: we have to be very careful about how to implement bind!
-- (because we are cheating with ML-style IO)
iobind :: IO a -> (a -> IO b) -> IO b
iobind action u _ = u (action Unit) Unit

ioliftA2 :: (a -> b -> c) -> IO a -> IO b -> IO c
ioliftA2 f act1 act2 = iobind act1 (\x -> iobind act2 (\y -> ioreturn (f x y)))

ioseq :: IO a -> IO b -> IO b
ioseq f g = iobind f (\_ -> g)

iosequence_ :: List (IO a) -> IO Unit
iosequence_ list = case list of { Nil -> ioret_ ; Cons a as -> ioseq a (iosequence_ as) }

iomapM :: (a -> IO b) -> List a -> IO (List b)
iomapM f list = case list of { Nil -> ioreturn Nil ; Cons x xs -> ioliftA2 Cons (f x) (iomapM f xs) }

ioforM :: List a -> (a -> IO b) -> IO (List b)
ioforM list f = iomapM f list

iomapM_ :: (a -> IO b) -> List a -> IO Unit
iomapM_ f list = case list of { Nil -> ioreturn Unit ; Cons x xs -> ioseq (f x) (iomapM_ f xs) }

ioforM_ :: List a -> (a -> IO b) -> IO Unit
ioforM_ list f = iomapM_ f list

getChar :: IO (Maybe Char)
getChar = getChar#

putChar :: Char -> IO Unit
putChar c = \_ -> putChar# c

exit :: Int -> IO Unit
exit k = \_ -> exit# k

getArg :: Int -> IO String
getArg i = \_ -> getArg# i 

getArgs :: IO (List String)
getArgs = go 0 where { go k = iobind (getArg k) (\mb -> case mb of 
  { Nothing   -> ioreturn Nil 
  ; Just this -> iobind (go (inc k)) (\rest -> ioreturn (Cons this rest)) })}

putStr :: String -> IO Unit
putStr xs = case xs of  { Nil -> ioret_ ; Cons y ys -> ioseq (putChar y) (putStr ys) }

putStrLn :: String -> IO Unit
putStrLn str = ioseq (putStr str) (putChar (chr 10)) 

type FilePath = String

openFile :: FilePath -> IOMode -> IO Handle
openFile fn mode = \_ -> openFile# fn mode

hClose :: Handle -> IO Unit
hClose h = \_ -> hClose# h

hGetChar :: Handle -> IO (Maybe Char)
hGetChar h = \_ -> hGetChar# h

hPutChar :: Handle -> Char -> IO Unit
hPutChar h c = \_ -> hPutChar# h c

hGetContents :: Handle -> IO String
hGetContents h = go where { go = iobind (hGetChar h) (\mb -> case mb of 
  { Nothing -> ioreturn Nil 
  ; Just y  -> iobind go (\ys -> ioreturn (Cons y ys)) }) }

hPutStr :: Handle -> String -> IO Unit
hPutStr h = go where { go xs = case xs of { Nil -> ioret_ ; Cons y ys -> ioseq (hPutChar h y) (go ys) } }

hPutStrLn :: Handle -> String -> IO Unit
hPutStrLn h str = ioseq (hPutStr h str) (hPutChar h (chr 10)) 

withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
withFile fn mode action =
  iobind (openFile fn mode) (\handle -> 
  iobind (action handle)    (\result -> 
  iobind (hClose handle)    (\_ -> ioreturn result)))

readFile :: FilePath -> IO String
readFile fn = withFile fn ReadMode hGetContents

writeFile :: FilePath -> String -> IO Unit
writeFile fn text = withFile fn WriteMode (\h -> hPutStr h text)

--------------------------------------------------------------------------------

compose :: (b -> c) -> (a -> b) -> (a -> c)
compose f g = \x -> f (g x)

listAnd xs = case xs of { Nil -> True ; Cons b bs -> and b (listAnd bs) }

listOr  = go where { go xs = case xs of { Nil -> False ; Cons b bs -> or b (go bs) } }

map :: (a -> b) -> List a -> List b
map f = go where { go xs = case xs of { Nil -> Nil ; Cons x xs -> Cons (f x) (map f xs) } }

for :: List a -> (a -> b) -> List b
for xs f = map f xs

filter :: (a -> Bool) -> List a -> List a
filter f = go where
  { go list = case list of
     { Nil -> Nil ; Cons x xs -> case f x of
       { False -> go xs ; True -> Cons x (go xs) } } }

inc :: Int -> Int
inc n = plus n 1

dec :: Int -> Int
dec n = minus n 1

gt :: Int -> Int -> Bool
gt x y = lt y x

ge :: Int -> Int -> Bool
ge x y = le y x

ceq :: Char -> Char -> Bool
ceq c d = eq (ord c) (ord d)

cneq :: Char -> Char -> Bool
cneq c d = not (ceq c d)

-- | the list [0,1,...n-1]
range :: Int -> List Int
range = rangeFrom 0

-- | the list [k,k+1,...k+n-1]
rangeFrom :: Int -> Int -> List Int
rangeFrom k n = ifte (gt n 0) (Cons k (rangeFrom (inc k) (dec n))) Nil

length :: List a -> Int
length ls = case ls of { Nil -> 0 ; Cons _ xs -> inc (length xs) }

foldl :: (a -> b -> a) -> (a -> List b -> a)
foldl f x0 list = go x0 list where
  { go x ls = case ls of { Nil -> x ; Cons y ys -> go (f x y) ys }
  }

flipFoldr :: (b -> a -> a) -> (List b -> a -> a)
flipFoldr f list y0 = go list y0 where
  { go ls y = case ls of { Nil -> y ; Cons x xs -> f x (go xs y) }
  }

foldr :: (b -> a -> a) -> (a -> List b -> a)
foldr f x list = flipFoldr f list x

sum :: List Int -> Int
sum = foldl plus 0 

reverse :: List a -> List a
reverse = foldl (\xs x -> Cons x xs) Nil 

append :: List a -> List a -> List a
append xs ys = case xs of { Nil -> ys ; Cons z zs -> Cons z (append zs ys) }

append3 :: List a -> List a -> List a -> List a
append3 xs ys zs = append xs (append ys zs)

concat :: List (List a) -> List a
concat lls = flipFoldr append lls Nil

showNat :: Int -> String
showNat n = ifte (lt n 0) (error "showNat: negative") (worker n) where
  { worker n = ifte (eq n 0) "0" (reverse (go n))
  ; go     n = ifte (eq n 0) Nil (Cons (chr (plus (mod n 10) 48)) (go (div n 10)))
  }

showInt :: Int -> String
showInt n = ifte (ge n 0) (showNat n) (Cons '-' (showNat (negate n)))


takeWhile :: (a -> Bool) -> List a -> List a
takeWhile cond = go where
  { go ls = case ls of { Nil -> Nil ; Cons x xs -> case cond x of
    { True -> Cons x (go xs) ; False -> Nil } } }

dropWhile :: (a -> Bool) -> List a -> List a
dropWhile cond = go where
  { go ls = case ls of { Nil -> Nil ; Cons x xs -> case cond x of
    { True -> go xs ; False -> xs } } }

span :: (a -> Bool) -> List a -> Pair (List a) (List a)
span cond xs = Pair (takeWhile cond xs) (dropWhile cond xs)

--------------------------------------------------------------------------------

intercalate :: List a -> List (List a) -> List a
intercalate sep = go where
  { go xss = case xss of
    { Nil -> Nil ; Cons ys yss -> case yss of
      { Nil -> ys
      ; _   -> append ys (append sep (go yss)) } } }

unwords :: List String -> String
unwords = intercalate (Cons ' '      Nil)

unlines :: List String -> String
unlines = intercalate (Cons newlineC Nil)

newlineC        = chr 10

lines :: String -> List String
lines xs = case xs of { Nil -> Nil ; Cons _ _ -> case span (\x -> cneq x newlineC) xs of
  { Pair this rest -> case rest of { Nil -> Cons this Nil ; Cons _ ys -> Cons this (lines ys) } } }

----

